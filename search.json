[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "What They Forgot to Teach You About R",
    "section": "",
    "text": "What They Forgot to Teach You About R\nThe initial impetus for creating these materials is a two-day hands-on workshop. The target learner:\nThe in-person workshops are still the primary delivery method for this content, but we’ve begun recording prose versions of this content, in order to make it more widely available and for participants to refer back to. Warning: these materials absolutely do not constitute a self-contained “book”, nor do they capture all workshop content.\nWe focus on building holistic and project-oriented workflows that address the most common sources of friction in data analysis, outside of doing the statistical analysis itself."
  },
  {
    "objectID": "index.html#workshops",
    "href": "index.html#workshops",
    "title": "What They Forgot to Teach You About R",
    "section": "Workshops",
    "text": "Workshops\nUpcoming and past offerings:\n\nposit::conf 2023, Chicago, IL\nrstudio::conf 2022, Oxon Hill, MD\nrstudio::conf 2020, San Francisco, CA\nrstudio::conf 2019, Austin, TX\nWTF Seattle Seattle, WA\nrstudio::conf 2018, San Diego, CA\n\nThe workshops typically include substantial components that draw on other materials, such as:\n\nHappy Git and GitHub for the useR\nIterating well with the purrr package\n\npurrr tutorial\nRow-oriented workflows in R with the tidyverse\n\n\nWhat They Forgot to Teach You About R by Jennifer Bryan, Jim Hester is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License."
  },
  {
    "objectID": "source-and-blank-slates.html#save-source-not-the-workspace",
    "href": "source-and-blank-slates.html#save-source-not-the-workspace",
    "title": "1  Saving source and blank slates",
    "section": "1.1 Save source, not the workspace",
    "text": "1.1 Save source, not the workspace\n\nThink of your R processes as livestock, not pets.\n\nI’m borrowing an analogy used to describe the ethos of cloud computing (history of this meme). Livestock is managed in herds and there is little fuss when individuals are lost or must be sacrificed. A pet, on the other hand, is unique and precious.\nWhy are individual servers disposable in cloud computing? Because they can be destroyed and replaced at any time and you generally have lots of them. Their creation is automated and the result of the work that they do is recorded in a file or other persistent data store.\nI recommend you cultivate a workflow in which you treat R processes (a.k.a. “sessions”) like livestock. Any individual R process and the associated workspace is disposable. Why might this be unappealing? This sounds terrible if your workspace is a pet, i.e. it holds precious objects and you aren’t 100% sure you can reproduce them. This fear is worth designing away, because attachment to your workspace indicates you have a non-reproducible workflow. This is guaranteed to lead to heartache.\nEverything that really matters should be achieved through code that you save.\n\n\n\n\n\nAll important objects or figures should be explicitly saved to file, in a granular way. This is in contrast to storing them implicitly or explicitly, as part of an entire workspace, or saving them via the mouse. These recommendations make useful objects readily available for use in other scripts or documents, with the additional assurance that they can be regenerated on-demand. (future link: the API for an analysis)\nSaving code – not workspaces – is incredibly important because it is an absolute requirement for reproducibility. Renouncing .Rdata and restarting R often are not intrinsically important or morally superior behaviours. They are important because they provide constant pressure for you to do the right thing: save the source code needed to create all important artefacts of your analysis.\nBelow we lay out the concrete measures for adopting this workflow."
  },
  {
    "objectID": "source-and-blank-slates.html#use-an-ide",
    "href": "source-and-blank-slates.html#use-an-ide",
    "title": "1  Saving source and blank slates",
    "section": "1.2 Use an IDE",
    "text": "1.2 Use an IDE\nWhen working with R, save your commands in a .R file, a.k.a. a script, or in .Rmd, a.k.a. an R Markdown document. It doesn’t have to be polished. Just save it!\nAn integrated development environment (IDE) is critical for making this workflow pleasant. Without an IDE, you edit your code in one app, copy one or more lines to the clipboard, then paste that into R, and execute. Over and over. If this is your life, it is very attractive to type code directly in R!\nAny good IDE offers a powerful, R-aware code editor and provides many ways to send your code to a running R process (along with other modern conveniences). This eliminates the temptation to develop code directly in the R Console. Instead, it becomes easier to do the right thing, which is to develop code in a .R or .Rmd file.\nSome popular IDEs:\n\nRStudio: download here or (I recommend) run the Preview version\nEmacs + ESS: https://ess.r-project.org\nvim + Nvim-R: blog post How to Turn Vim Into an IDE for R\nVisual Studio Code: https://code.visualstudio.com/docs/languages/r\n\nSometimes people resist advice because it’s hard to incorporate into their current workflow and dismiss it as something “for experts only”. But this gets the direction of causality backwards: long-time and professional coders don’t do these things because they use an IDE. They use an IDE because it makes it so much easier to follow best practices."
  },
  {
    "objectID": "source-and-blank-slates.html#always-start-r-with-a-blank-slate",
    "href": "source-and-blank-slates.html#always-start-r-with-a-blank-slate",
    "title": "1  Saving source and blank slates",
    "section": "1.3 Always start R with a blank slate",
    "text": "1.3 Always start R with a blank slate\nWhen you quit R, do not save the workspace to an .Rdata file. When you launch, do not reload the workspace from an .Rdata file.\n\nIn RStudio, set this via Tools > Global Options.\n\n\n\n\n\n\nvia R for Data Science\n\n\n\n\nFYI: `usethis::use_blank_slate()` prints a reminder about how to do this.\n\nIf you run R from the shell, launch with R --no-save --no-restore-data. You might want to define an alias in your .bash_profile: alias R='R --no-save --no-restore-data'. Learn more by executing R --help in a shell."
  },
  {
    "objectID": "source-and-blank-slates.html#restart-r-often-during-development",
    "href": "source-and-blank-slates.html#restart-r-often-during-development",
    "title": "1  Saving source and blank slates",
    "section": "1.4 Restart R often during development",
    "text": "1.4 Restart R often during development\n\nHave you tried turning it off and then on again?\n– timeless troubleshooting wisdom, applies to everything\n\nIf you use RStudio, use the menu item Session > Restart R or the associated keyboard shortcut Ctrl+Shift+F10 (Windows and Linux) or Command+Shift+F10 (Mac OS). Additional keyboard shortcuts make it easy to restart development where you left off, i.e. to say “re-run all the code up to HERE”:\n\nIn an R script, use Ctrl+Alt+B (Windows and Linux) or Command+Option+B (Mac OS)\nIn R markdown, use Ctrl+Alt+P (Windows and Linux) or Command+Option+P (Mac OS)\n\nIf you run R from the shell, use Ctrl+D or q() to quit, then restart R.\n\n1.4.1 Pre-emptively handling a FAQ\nNo, there is no R command you can put at the top of a script to restart R before executing the rest of the file.\nNo, this is a not a good reason to build RStudio API hacks into your scripts. We shall not speak of your favorite trick that starts with .rs.api.*.\nYou use a menu or keyboard shortcut to save your code or to re-indent it or run a spell-checker, right? This is how you should approach restarting R periodically during the day. It’s a workflow task. It does not belong in your code.\nWhich brings us to …"
  },
  {
    "objectID": "source-and-blank-slates.html#rm-list-ls",
    "href": "source-and-blank-slates.html#rm-list-ls",
    "title": "1  Saving source and blank slates",
    "section": "1.5 What’s wrong with rm(list = ls())?",
    "text": "1.5 What’s wrong with rm(list = ls())?\nIt’s fairly common to see data analysis scripts that begin with this object-nuking command:\n\nrm(list = ls())\n\nThis is highly suggestive of a non-reproducible workflow.\nThis line is meant to reset things, either to power-cycle the current analysis or to switch from one project to another. But there are better ways to do both:\n\nTo power-cycle the current analysis, restart R! See above.\nTo switch from one project to another, either restart R or, even better, use an IDE with proper support for projects, where each project gets its own R process. See Project-oriented workflow.\n\nThe problem with rm(list = ls()) is that, given the intent, it does not go far enough. All it does is delete user-created objects from the global workspace.\nMany other changes to the R landscape persist invisibly and can have profound effects on subsequent development. Any packages that have ever been attached via library() are still available. Any options that have been set to non-default values remain that way. Working directory is not affected (which is, of course, why we see setwd() so often here too!).\nWhy does this matter? It makes your script vulnerable to hidden dependencies on things you ran in this R process before you executed rm(list = ls()).\n\nYou might use functions from a package without including the necessary library() call. Your collaborator won’t be able to run this script.\nYou might code up an analysis assuming that stringsAsFactors = FALSE but next week, when you have restarted R, everything will inexplicably be broken.\nYou might write paths relative to some random working directory, then be puzzled next month when nothing can be found or results don’t appear where you expect.\n\nThe solution is to write every script assuming it will be run in a fresh R process. The best way to do that is … develop scripts in a fresh R process!\nThere is nothing inherently evil about rm(list = ls()). It’s a red flag, because it is indicative of a non-reproducible workflow. Since it appears to “work” ~90% of the time, it’s very easy to deceive yourself into thinking your script is self-contained, when it is not."
  },
  {
    "objectID": "source-and-blank-slates.html#objects-that-take-a-long-time-to-create",
    "href": "source-and-blank-slates.html#objects-that-take-a-long-time-to-create",
    "title": "1  Saving source and blank slates",
    "section": "1.6 Objects that take a long time to create",
    "text": "1.6 Objects that take a long time to create\nPower-cycling your analysis regularly can be very painful if there are parts that take a long time to execute.\nThis indicates it’s time for a modular approach that breaks the analysis into natural phases, each with an associated script and outputs. (future link: API for an analysis) Isolate each computationally demanding step in its own script and write the precious object to file with saveRDS(my_precious, here(\"results\", \"my_precious.rds\")). Now you can develop scripts to do downstream work that reload the precious object via my_precious <- readRDS(here(\"results\", \"my_precious.rds\")). Breaking an analysis into logical steps, with clear inputs and outputs, is a good idea anyway."
  },
  {
    "objectID": "source-and-blank-slates.html#automated-workflows",
    "href": "source-and-blank-slates.html#automated-workflows",
    "title": "1  Saving source and blank slates",
    "section": "1.7 Automated workflows",
    "text": "1.7 Automated workflows\nVarious approaches exist for automating a workflow, i.e. running a set of scripts in sequence. Many people can get by with low-tech solutions, such as using GNU Make or even writing a pseudo-Makefile in R.\nIf you use one “controller” script to run other R scripts or to render multiple R Markdown documents, it’s a good idea to force the use of a fresh R process for each one. If your controller script is written in R, consider using the callr package to source() or render() each worker script or .Rmd in its own R session.\nThe R package targets is gaining traction as a formal tool for workflow automation (sort of GNU make, but for R):\n\ntargets skips costly runtime for tasks that are already up to date, [and] orchestrates the necessary computation with implicit parallel computing…"
  },
  {
    "objectID": "source-and-blank-slates.html#links-to-other-resources",
    "href": "source-and-blank-slates.html#links-to-other-resources",
    "title": "1  Saving source and blank slates",
    "section": "1.8 Links to other resources",
    "text": "1.8 Links to other resources\nThis page from STAT 545 covers some of the same ground, but aimed at someone quite new to R.\nThe post Project-oriented workflow from the tidyverse blog is an earlier effort to explain why rm(list = ls()) and setwd() indicate a sub-optimal workflow.\n\nThat lead to a lively thread on community.rstudio.com where lots of useRs share their experience and tricks."
  },
  {
    "objectID": "projects.html#setwd",
    "href": "projects.html#setwd",
    "title": "2  Project-oriented workflow",
    "section": "2.1 We need to talk about setwd(\"path/that/only/works/on/my/machine\")",
    "text": "2.1 We need to talk about setwd(\"path/that/only/works/on/my/machine\")\nA common response to the working directory problem is to set the working directory at the beginning of each script via setwd(). At the start of STAT 545, we see a lot of student code that looks like this:\n\nlibrary(ggplot2)\nsetwd(\"/Users/jenny/cuddly_broccoli/verbose_funicular/foofy/data\")\ndf <- read.delim(\"raw_foofy_data.csv\")\np <- ggplot(df, aes(x, y)) + geom_point()\nggsave(\"../figs/foofy_scatterplot.png\")\n\nThe chance of the setwd() command having the desired effect – making the file paths work – for anyone besides its author is 0%. It’s also unlikely to work for the author one or two years or computers from now. To recreate and perhaps extend this plot, the lucky recipient will need to hand edit one or more paths to reflect where the project has landed on their machine.\nHard-wired, absolute paths, especially when sprinkled throughout the code, make a project brittle. Such code does not travel well across time or space.\nIf, after reading this article, you still decide to use setwd() in your scripts, you should at least be very disciplined about it:\n\nOnly use setwd() at the very start of a file, i.e. in an obvious and predictable place. If someone has to hand-edit all of these, make it easy for them.\nAlways set working directory to the same thing, namely to the top-level of the project (not a subdirectory). Always build subsequent paths relative to that. Here’s how that looks in the previous example:\n\nsetwd(\"/Users/jenny/cuddly_broccoli/verbose_funicular/foofy\")\n\nlibrary(ggplot2)\ndf <- read.delim(\"data/raw_foofy_data.csv\")\np <- ggplot(df, aes(x, y)) + geom_point()\nggsave(\"figs/foofy_scatterplot.png\")\n\n\nThe convention about leaving working directory at the top-level of a project is tightly connected to topics in @ref(safe-paths).\n\n2.1.1 If you like setwd(), then carry on\nIf you use setwd(\"path/that/only/works/on/my/machine\") and it does not cause you or your collaborators grief, then I am happy for you. Carry on. This was my practice as well for many years.\nBut eventually I admitted that this did cause me grief whenever I moved my files, collaborated on an analysis with a colleague, or got a new computer. Then, as the instructor of STAT545, I started to run other people’s code en masse. Up to 80 students submitted multiple .R and .Rmd files each week, riddled with setwd() calls that required artisanal hand editing by me. This was the straw that broke the camel’s back and made me determined to clearly articulate this problem and some solutions. You can design this particular aggravation out of your life."
  },
  {
    "objectID": "projects.html#dilemma-and-a-solution",
    "href": "projects.html#dilemma-and-a-solution",
    "title": "2  Project-oriented workflow",
    "section": "2.2 Dilemma and a solution",
    "text": "2.2 Dilemma and a solution\nProblem statement:\n\nWe want to work on project A with R’s working directory set to path/to/projectA and on project B with R’s working directory set to path/to/projectB.\nBut we also want to keep code like setwd(\"path/to/projectA\") out of our .R scripts.\n\nThe lowest-tech solution is to simply set working directory yourself, interactively, at the same time as you restart R, when you switch from project A to project B. Execute setwd(\"path/to/projectA\"), but don’t bake it into your scripts. This works! But it’s aggravating enough that most people go back to using setwd() anyway and/or are reluctant to cycle rapidly between projects.\nI strongly recommend using an IDE that supports a project-based workflow. This eliminates the tension between your development convenience and the portability of the code."
  },
  {
    "objectID": "projects.html#work-in-a-project",
    "href": "projects.html#work-in-a-project",
    "title": "2  Project-oriented workflow",
    "section": "2.3 Organize work into projects (colloquial definition)",
    "text": "2.3 Organize work into projects (colloquial definition)\nHere’s what I mean by “work in a project”:\n\nFile system discipline: put all the files related to a single project in a designated folder.\n\nThis applies to data, code, figures, notes, etc.\nDepending on project complexity, you might enforce further organization into subfolders.\nOther common file practices are detailed in API for an analysis and How to name files.\n\nWorking directory intentionality: when working on project A, make sure working directory is set to project A’s folder.\n\nIdeally, this is achieved via the development workflow and tooling, not by baking absolute paths into the code.\n\nFile path discipline: all paths are relative and, by default, relative to the project’s folder.\n\nThese habits are synergistic: you’ll get the biggest payoff if you practice all of them together.\nThese habits guarantee that the project can be moved around on your computer or onto other computers and will still “just work”. I argue that this is the only practical convention that creates reliable, polite behavior across different computers or users and over time. This convention is neither new, nor unique to R.\nIt’s like agreeing that we will all drive on the left or the right. A hallmark of civilization is following conventions that constrain your behavior a little, in the name of public safety."
  },
  {
    "objectID": "projects.html#ide-support-for-projects",
    "href": "projects.html#ide-support-for-projects",
    "title": "2  Project-oriented workflow",
    "section": "2.4 IDE support for projects",
    "text": "2.4 IDE support for projects\nProjects are a common and very attractive feature of many IDEs (@ref(use-an-ide)). Again, the practice of organizing work in projects is not prevalent among long-time coders because they use an IDE. It’s the other way around: one of the attractions of an IDE is that it makes it easier to exploit development practices that have proven to be useful across many languages and domains.\nI would say an IDE or workflow supports project-oriented work in R if there’s a way to do these things:\n\nLaunch the IDE in project A:\n\nStarts R.\nSets working directory to the project’s folder.\n\nSwitch a running instance of the IDE from project A to project B:\n\nRestarts R.\nSets working directory to the project’s folder.\nOptional but nice: restores previously open files, i.e. pick up where you left off.\n\nHave project A and project B open for simultaneous work:\n\nEach project gets its own R process, with working directory set appropriately.\nOptional but nice: multiple projects feel like multiple instances of the IDE and you can use a conventional method to switch between them, e.g. Command+Tab (Mac OS) or Alt+Tab (Windows)."
  },
  {
    "objectID": "projects.html#rstudio-projects",
    "href": "projects.html#rstudio-projects",
    "title": "2  Project-oriented workflow",
    "section": "2.5 RStudio Projects",
    "text": "2.5 RStudio Projects\nThe RStudio IDE has a notion of a (capital “P”) Project, which is a very effective implementation of the (small “p”) projects described above.\nYou can designate a new or existing folder as a Project. All this means is that RStudio leaves a file, e.g., foofy.Rproj, in the folder, which is used to store settings specific to that project. Use File > New Project … to get started.\nDouble-click on a .Rproj file to open a fresh instance of RStudio, with the working directory and file browser pointed at the project folder.\nOnce RStudio is running, you can open an existing Project, switch to another Project, launch a second instance of RStudio in a new or existing Project, and much more, via various menus and keyboard shortcuts (more below).\nHere’s a screenshot of the Mac OS app switcher invoked via Command+Tab, showing multiple simultaneous instances of RStudio.\n\n\n\n\n\nThis allows rapid context switching across several projects, such as an R package, teaching material, and a data analysis. There is no danger of crosstalk between the projects: each has its own R process, global workspace, and working directory.\n\n2.5.1 Tricks for opening Projects\nOnce you decide “I want to do some work in Project K”, there are various ways to accelerate the startup process. I’ll review a few going from general and low-tech to more specific.\nHave a dedicated folder for your Projects. I keep the vast majority of my R work in RStudio Projects in the folder ~/rrr/. What I call this folder and where I keep it is not important. The main point is if you have One Main Place for Projects, then you can go there in Finder or File Explorer and drill down to the .Rproj file needed to launch any specific project. You can make the One Main Place more accessible to yourself by putting it in the Finder’s Sidebar (macOS) or in the Navigation Pane (Windows).\nRStudio knows about recently used Projects. Once you are in RStudio, there are several ways to access other Projects you’ve recently worked in. In the upper right corner is a drop-down menu with various Project- and session-related goodies in it.\n\n\n\n\n\nUse the “arrow and paper” icon to open a Project in a separate RStudio instance, while also leaving the Project you’re launching it from open. Click on a Project’s name to switch the current RStudio instance from one Project to another. The File menu also offers ways to switch project or open new, additional instances.\nFind and Launch Projects with Alfred. This is a highly specific app recommendation that only works on macOS, but I’m sure other tools have a similar capability on macOS and Windows. I use Alfred, which is a macOS application launcher and general productivity booster, based on a recommendation from Hadley Wickham.\nYou will set an Alfred hotkey (I use Option + Space), similar to macOS Spotlight. The hotkey calls up a search window, where you can summon apps or files. I’ve configured Alfred to search preferentially for .Rproj files here, making it extremely easy to find and launch RStudio Projects. Here’s what happens when I type “tidy”:\n\n\n\n\n\nYou can achieve this by “registering” the .Rproj file type with Alfred. Go to Alfred’s Preferences > Features > Default Results > Advanced…. Drag any .Rproj file onto this space and then close."
  },
  {
    "objectID": "projects.html#other-ways-to-work-with-projects",
    "href": "projects.html#other-ways-to-work-with-projects",
    "title": "2  Project-oriented workflow",
    "section": "2.6 Other ways to work with projects",
    "text": "2.6 Other ways to work with projects\nAspirational placeholder.\nWill hopefully sketch project-friendly workflows that are not RStudio, e.g. Emacs + ESS. They do exist but I am not expert in them and an open to input from those who are. Links to well-developed guides would be best as I don’t want to ingest anything I can’t maintain.\n\n2.6.1 Project-specific shortcuts on Windows\nstill rough\nAfter installing R, you will have a shortcut to Rgui.exe on your desktop and/or somewhere on the Start menu file tree, and perhaps also in the Quick Launch part of the taskbar (Vista and earlier).\nCreate a copy of this shortcut for each project. Right-click the new shortcut, select Properties..., and change the ‘Start in’ field to the folder where the project lives.\nLaunch R in a project by double-clicking its suitably-prepared shortcut.\nSource:\n\nR for Windows FAQ question 2.10 How can I keep workspaces for different projects in different directories?"
  },
  {
    "objectID": "projects.html#links-to-other-resources",
    "href": "projects.html#links-to-other-resources",
    "title": "2  Project-oriented workflow",
    "section": "2.7 Links to other resources",
    "text": "2.7 Links to other resources\nThis page from STAT 545 covers some of the same ground, but aimed at someone quite new to R.\nThe post Project-oriented workflow from the tidyverse blog is an earlier effort to explain why rm(list = ls()) and setwd() indicate a sub-optimal workflow.\n\nThat lead to a lively thread on community.rstudio.com where lots of useRs share their experience and tricks."
  },
  {
    "objectID": "practice-safe-paths.html#use-projects-and-the-here-package",
    "href": "practice-safe-paths.html#use-projects-and-the-here-package",
    "title": "3  Practice safe paths",
    "section": "3.1 Use projects and the here package",
    "text": "3.1 Use projects and the here package\nHow can you avoid setwd() at the top of every script?\n\nOrganize each logical project into a folder on your computer.\nMake sure the top-level folder advertises itself as such. This can be as simple as having an empty file named .here. Or, if you use RStudio and/or Git, those both leave characteristic files behind that will get the job done.\nUse the here() function from the here package to build the path when you read or write a file. Create paths relative to the top-level directory.\nWhenever you work on this project, launch the R process from the project’s top-level directory. If you launch R from the shell, cd to the correct folder first.\n\nTo continue our example, start R in the foofy directory, wherever that may be. Now the code looks like so:\n\nlibrary(ggplot2)\nlibrary(here)\n\ndf <- read.delim(here(\"data\", \"raw_foofy_data.csv\"))\np <- ggplot(df, aes(x, y)) + geom_point()\nggsave(here(\"figs\", \"foofy_scatterplot.png\"))\n\nThis will run, with no edits, for anyone who follows the convention about launching R in the project folder. In fact, it will even work if R’s working directory is anywhere inside the project, i.e. it will work from sub-folders. This plays well with knitr/rmarkdown’s default behavior around working directory and in package development/checking workflows.\nRead up on the here package to learn about more features, such as additional ways to mark the top directory and troubleshooting with dr_here(). I have also written a more detailed paean to this package before."
  },
  {
    "objectID": "naming-files.html",
    "href": "naming-files.html",
    "title": "4  How to name files",
    "section": "",
    "text": "Convert content from these slides https://speakerdeck.com/jennybc/how-to-name-files"
  },
  {
    "objectID": "api-for-an-analysis.html",
    "href": "api-for-an-analysis.html",
    "title": "5  API for an analysis",
    "section": "",
    "text": "Prose version of slides 57 - 63 from here:\nhttps://speakerdeck.com/jennybc/zen-and-the-art-of-workflow-maintenance?slide=57"
  },
  {
    "objectID": "get-to-know-your-r-installation.html",
    "href": "get-to-know-your-r-installation.html",
    "title": "6  Get to know your R installation",
    "section": "",
    "text": "R version, where the executable lives.\nStudy your package library."
  },
  {
    "objectID": "r-startup.html#renviron",
    "href": "r-startup.html#renviron",
    "title": "7  R Startup",
    "section": "7.1 .Renviron",
    "text": "7.1 .Renviron\nThe .Renviron file is most useful for defining sensitive information such as API keys (such as GitHub or twitter) as well as R specific environment variables like the history size (R_HISTSIZE=100000) and default library locations R_LIBS_USER.\nThe .Renviron file contains lists of environment variables to set. This is not R code, it uses a format similar to that used on the command line shell.\nThe easiest way to edit .Renviron is by running usethis::edit_r_environ().\nA simple example of a .Renviron file is\nR_HISTSIZE=100000\nGITHUB_PAT=abc123\nR_LIBS_USER=~/R/%p/%v\n\n\n\nTry the activity usethis::use_course(“rstd.io/wtf-source-package”)\n\n\nto learn how to set a GitHub PAT to your .Renviron and then use it with usethis::use_github() to upload a project to GitHub."
  },
  {
    "objectID": "r-startup.html#rprofile",
    "href": "r-startup.html#rprofile",
    "title": "7  R Startup",
    "section": "7.2 .Rprofile",
    "text": "7.2 .Rprofile\nThe .Rprofile file contains R code to be run when R starts up. It is run after the .Renviron file is sourced. Typically .Rprofile is located in the users’ home directory (~/.Rprofile), however a different location can be configured by setting the R_PROFILE_USER environment variable.\nThe easiest way to edit .Rprofile is by running usethis::edit_r_profile().\nSome common things people often add to their .RProfile\n\nSet a default CRAN mirror\nWrite a welcome message\nCustomize their R prompt\nChange options, screen width, numeric display\nLoad frequently used packages (but be very careful)\nAliases / shortcuts for frequently used functions\n\n\n7.2.1 Reproducibility\nA good rule of thumb is you should only put things in your .Rprofile that you run interactively in the R terminal. If it ever appears in a R script or R Markdown file it should not be in your .Rprofile.\nIf you set these options in your .Rprofile, then try to run one of your scripts on another system without your .Rprofile it will no longer be reproducible. Some problematic examples are loading packages used in analysis (such as dplyr or ggplot2) or changing default options which change the value of outputs, such as options(stringsAsFactors = FALSE).\nIn addition because the .Rprofile is run by every R process (including those started by R itself) it is important to guard most of the code with interactive(), so it is only run in interactive sessions (sessions you are controlling with a terminal).\nA simple example of a .Rprofile is\noptions(repos = c(CRAN = \"https://cran.rstudio.org\"))\n\nif (interactive()) {\n  options(width = 120)\n}\n\n\n\nTry the activity usethis::use_course(“rstd.io/wtf-source-package”)\n\n\nto learn how to create a .Rprofile with a default CRAN repository and add a startup message to it."
  },
  {
    "objectID": "r-startup.html#disabling-startup-files",
    "href": "r-startup.html#disabling-startup-files",
    "title": "7  R Startup",
    "section": "7.3 Disabling startup files",
    "text": "7.3 Disabling startup files\nYou can run R without any startup files by using the --vanilla argument when starting R. In RStudio you can do this by checking the option Project Options -> Disable .Rprofile execution on session start / resume. You can also selectively disable only the user or site .Rprofile with --no-init-file and --no-site-file respectively, and disable the environment files with --no-environ.\n\n\n\nBoth .Renviron and .Rprofile must end with a newline character. If they do not the last line with be ignored without a warning or error."
  },
  {
    "objectID": "maintaining-r.html#how-to-upgrade-an-installed-package-to-the-latest-version.",
    "href": "maintaining-r.html#how-to-upgrade-an-installed-package-to-the-latest-version.",
    "title": "8  Maintaining R",
    "section": "8.1 How to upgrade an installed package to the latest version.",
    "text": "8.1 How to upgrade an installed package to the latest version.\nSometimes you would like to upgrade a particular package to the latest available version. Often this is because you have heard about a new feature, or maybe you have run into a bug that may have been fixed.\n\n8.1.1 In RStudio\n\n\n\nRStudio has an update dialog (Packages Tab -> Update). Check packages to update them\n\n\n\n\n8.1.2 R terminal\nDevtools has a function update_packages() which will upgrade a package (from the same source) for any CRAN or development package.\ndevtools::update_packages(\"pkgname\")\nIn addition if the given package is not already installed it will install it."
  },
  {
    "objectID": "maintaining-r.html#how-to-upgrade-all-out-of-date-packages",
    "href": "maintaining-r.html#how-to-upgrade-all-out-of-date-packages",
    "title": "8  Maintaining R",
    "section": "8.2 How to upgrade all out-of-date packages",
    "text": "8.2 How to upgrade all out-of-date packages\n\n8.2.1 In RStudio\n\n\n\nRStudio also allows you to update all packages (Packages Tab -> Update -> Select All)\n\n\n\n\n8.2.2 CRAN packages\ndevtools::update_packages(TRUE)"
  },
  {
    "objectID": "maintaining-r.html#how-to-downgrade-a-package",
    "href": "maintaining-r.html#how-to-downgrade-a-package",
    "title": "8  Maintaining R",
    "section": "8.3 How to downgrade a package",
    "text": "8.3 How to downgrade a package\nFirst if unsure what version -> CRAN page -> pkgname archive\ndevtools::install_version(\"devtools\", \"1.13.3\")"
  },
  {
    "objectID": "maintaining-r.html#how-to-transfer-your-library-when-updating-r",
    "href": "maintaining-r.html#how-to-transfer-your-library-when-updating-r",
    "title": "8  Maintaining R",
    "section": "8.4 How to transfer your library when updating R",
    "text": "8.4 How to transfer your library when updating R\nOften you will not need to do anything when updating R. For ‘patch’ R versions, the ‘z’ in ‘x.y.z’ the R core developers ensure package compatibility across versions. So if you are updating from R 3.5.0 to R 3.5.1 you can use the same packages you are currently using.\nFor ‘minor’ version changes, the ‘y’ in ‘x.y.z’ the package interface can change, so packages need to be re-installed.\n\n\n\nYou may see some suggestions that you can just copy your packages even when the ‘minor’ version changes. DO NOT DO THIS. While it may work some (even most) of the time, R-core does not guarantee compatibility between these versions and things could break (even break silently).\n\n\n\nI suggest you keep the packages R comes with (base and recommended) packages separate from the rest of your packages. This makes it easy to re-install R if needed without touching your CRAN packages. You also want to make sure the package library is specific to the minor version of R.\nR_LIBS_USER is actually set by default to this scheme, (to ~/R/win-library/x.y on Windows and ~/Library/R/x.y/library on macOS) but the directory may not already exist, so one option is just to create this directory (fs::dir_create(Sys.getenv(\"R_LIBS_USER\"))).\nYou can also alternatively set R_LIBS_USER to a different path; but make sure to include the %v wildcard. e.g. ~/R/library/%v. The %v is automatically expanded to the major and minor version of R, so with R 3.5.1 this path becomes ~/R/library/3.5. See Renviron for how to edit your .Renviron file.\n\n\n\nPaths in R_LIBS_USER are only used if the directories they specify actually exist. So in addition to adding R_LIBS_USER to your .Renviron you need to create the directory as well.\n\n\n\nOnce this is setup, the process for transferring your package library becomes. (assumes R_LIBS_USER is set to ~/Library/R/3.5/library).\n# Install new version of R (lets say 3.5.0 in this example)\n\n# Create a new directory for the version of R\nfs::dir_create(\"~/Library/R/3.5/library\")\n\n# Re-start R so the .libPaths are updated\n\n# Lookup what packages were in your old package library\npkgs <- fs::path_file(fs::dir_ls(\"~/Library/R/3.4/library\"))\n\n# Filter these packages as needed\n\n# Install the packages in the new version\ninstall.packages(pkgs)"
  },
  {
    "objectID": "install-single-package.html#installation-to-a-temporary-library",
    "href": "install-single-package.html#installation-to-a-temporary-library",
    "title": "9  Install a source package",
    "section": "9.1 Installation to a temporary library",
    "text": "9.1 Installation to a temporary library\nIt is sometimes useful to install packages to a temporary library, so that they don’t affect your normal packages. This can be done by using the lib argument to the devtools install functions, then using lib.loc in library() when you load the package.\nlibrary(devtools)\n\ntmp_lib <- \"~/tmp/tmp_library\"\ndir.create(tmp_lib)\n\ndevtools::install_github(\"dill/beyonce\", lib = tmp_lib)\n\n## restart R\n\n## explicitly load the affected packages from the temporary library\nlibrary(beyonce, lib.loc = tmp_lib)\n\n## your experimentation goes here\n\n## done? clean up!\nunlink(tmp_lib, recursive = TRUE)\n\n\n\nTry the activity: usethis::use_course(“rstd.io/wtf-source-package”)\n\n\nTo practice installing various types of source packages."
  },
  {
    "objectID": "debugging-r.html#debugging-your-own-code",
    "href": "debugging-r.html#debugging-your-own-code",
    "title": "10  Debugging R code",
    "section": "10.1 Debugging your own code",
    "text": "10.1 Debugging your own code\nThe most common case you will run into a bug is when writing new code yourself. Often the mistake is obvious and easily fixed, but sometimes it only appears after multiple levels of calls and is harder to diagnose. There are a few common strategies to use when debugging your own code.\n\nUse traceback() to determine where a given error is occurring.\nOutput diagnostic information in code with print(), cat() or message() statements.\nUse browser() to open an interactive debugger before the error\nUse debug() to automatically open a debugger at the start of a function call.\nUse trace() to start a debugger at a location inside a function.\n\n\n10.1.1 traceback()\nThe traceback() function can be used to print a summary of how your program arrived at the error. This is also called a call stack, stack trace or backtrace.\nIn R this gives you each call that lead up to the error, which can be very useful for determining what lead to the error.\nYou can use traceback() in two different ways, either by calling it immediately after the error has occurred.\n\n\nf <- function(x) x + 1\ng <- function(x) f(x)\ng(\"a\")\n\n#> Error in x + 1 : non-numeric argument to binary operator\ntraceback()\n#> 2: f(x) at #1\n#> 1: g(\"a\")\nOr by using traceback() as an error handler, which will call it immediately on any error. (You could even put this in your .Rprofile)\n\noptions(error = traceback)\ng(\"a\")\n\n#> Error in x + 1 : non-numeric argument to binary operator\n#> 2: f(x) at #1\n#> 1: g(\"a\")\n\n\n10.1.2 print()\nOnce you know where an error occurs it is then helpful to know why. Often errors occur because functions are given inputs their authors did not expect, so it is useful to print the value of objects during execution.\nThe most basic way to do this is to sprinkle messages throughout your code, with print() or str(). str() is often more useful because it gives more detail into the exact structure of an object, which may not be the structure you expect it to be.\nThe main downsides to the print approach is you often have to add them in multiple places to narrow down the error, and you cannot further investigate the object.\n\n\n10.1.3 browser()\nA more sophisticated debugging method is to put a call to browser() in your code. This will stop execution at that point and open R’s interactive debugger. In the debugger you can run any R command to look at objects in the current environment, modify them and continue executing.\nSome useful things to do are\n\nUse ls() to determine what objects are available in the current environment. This allows you to see exactly what things you can examine.\nUse str(), print() etc. to examine the objects\nUse n to evaluate the next statement. Use s to evaluate the next statement, but step into function calls.\nUse where to print a stack trace\nUse c to leave the debugger and continue execution\nUse Q to exit the debugger and return to the R prompt."
  },
  {
    "objectID": "debugging-r.html#debugging-in-rstudio",
    "href": "debugging-r.html#debugging-in-rstudio",
    "title": "10  Debugging R code",
    "section": "10.2 Debugging in RStudio",
    "text": "10.2 Debugging in RStudio\n\n10.2.1 Editor breakpoints\nRStudio provides some additional tooling for debugging over using R on the command line. First you can set an editor breakpoint by clicking to the left of the line number in the source file, or by pressing Shift+F9 with your cursor on the line. A breakpoint is equivalent to a browser() call, but you avoid needing to change your code like browser().\n\n\n\n10.2.2 Stopping on error\nIf you are trying to hunt down a particular error it is often useful to have RStudio enter the debugger when it occurs. You can control the error behavior with (Debug -> On Error -> Error Inspector).\n\n\n\n10.2.3 Debugging console\n\nThe RStudio debugging console has a few buttons to make debugging a little nicer, From left to right they are, next (equivalent to n), step info (s), continue (c) and Stop (Q)."
  },
  {
    "objectID": "debugging-r.html#debugging-others-code",
    "href": "debugging-r.html#debugging-others-code",
    "title": "10  Debugging R code",
    "section": "10.3 Debugging others’ code",
    "text": "10.3 Debugging others’ code\nWhen the error is occurring outside of your own code it is also useful to be able to debug the code. In this case you could download the package code locally and debug it like you would with your own code above by adding print() and / or browser() calls. Because R and most R packages are open source this is a perfectly viable option and one I often do myself. However depending on the package this can sometimes be challenging, particularly for those packages which come with R itself.\nThe other option is to use additional functions which allow you to start a browser in existing functions, recover(), debug(), trace() .\n\n10.3.1 recover()\nrecover() is not used directly, instead it is used as an error handler, by calling options(error = recover). You can also use other functions, such as browser() as an error handler, which will start the debugger automatically when there is an error.\nThe benefit to recover() over using options(error = browser) is that you can browse on any of the call stack, not just where the error occurred. Often the issue is most easily diagnosed in calls higher on the stack than immediately where the error occurred.\nWhen recover() is called it prints a list of the current calls, with a prompt to select which you want to browse in. Then a debugging session is started at that location.\n\n\n\nTry activity 1 usethis::use_course(“rstd.io/wtf-debugging”) Try activity 2 usethis::use_course(“rstd.io/wtf-debugging”)\n\n\nto practice debugging errors using the tools described\n\n\n\n\n\n10.3.2 debug()\nIf you have control of the code (because you are the one writing it), using browser() is generally the most convenient way to enter the debugger. However if the error is occurring in code in a package what options do you have?\nThis is where the debug() function is useful, it will open the R debugger on any function, including those in packages.\ndebug(ggplot2::ggplot)\nUse can use the :: syntax to find ‘exported’ functions in a package, but there is also a way to access any function, including un-exported ones, :::.\ndebug(ggplot2:::set_last_plot)\nundebug() is used to remove the debugging code.\n\n\n10.3.3 trace()\ndebug() is very useful, but one drawback is it always executes the first time a function is called. What can you do if the bug only happens the 100th time a function is called?\ntrace() is a more flexible version of debug() that not only lets you start a debugger at the start of a function, it lets you insert any code at any location in a function. The downside to this power and flexibility is that trace() is comparatively harder to use than debug().\nIf called with no additional arguments trace() simply prints a message when the function is entered.\nIf called with a function as the second argument this inserts the function at the start of the function. trace(fun, browser) is functionally equivalent to debug(fun). browser() or revover() are generally the most useful functions to use, but this could actually be any R function or even regular R expressions. This is often useful to open the debugger only when a certain condition is met.\n\ntrace(print, quote(if (is.numeric(x) && x >= 3) cat(\"hi\\n\")), print = FALSE)\n\nTracing function \"print\" in package \"base\"\n\n\n[1] \"print\"\n\nprint(1)\n\n[1] 1\n\nprint(3)\n\nhi\n[1] 3\n\n# Use untrace to remove the tracing code\nuntrace(print)\n\nUntracing function \"print\" in package \"base\"\n\n\nYou can also use the at argument to trace() to insert the tracing expressions at other points in the function body. To determine the number of the expression to insert convert the body of the function to a list. e.g. as.list(body(fun)).\n\n\n\nTry activity 3 usethis::use_course(“rstd.io/wtf-debugging”)\n\n\nto explore using trace() with at."
  },
  {
    "objectID": "debugging-r.html#debugging-in-r-markdown-documents",
    "href": "debugging-r.html#debugging-in-r-markdown-documents",
    "title": "10  Debugging R code",
    "section": "10.4 Debugging in R Markdown documents",
    "text": "10.4 Debugging in R Markdown documents\nOne special case where it can sometimes be more difficult to debug is an error that occurs only when knitting an R Markdown document.\nThe easiest way to debug most of the errors is to simply run the code inside the chunk as regular R code in the console and use the normal techniques such as inserting browser() calls.\nHowever rarely an error will only occur when the code is being knitted. In this case you can set an error handler with the following code.\nFirst you will need to modify recover slightly, by adding a sink() call to the beginning, which disables the sink used by knitr internally. We do this by using trace(). This can be run in a setup block or in your R console before calling knitr::knit() / rmarkdown::render()\ntrace(recover, sink)\nThen add the following knitr chunk options to the chunk which is failing. error = FALSE, R.options = list(error = recover).\nThen knit the file on the R console with knitr::knit() or rmarkdown::render(). The traceback will contain all of the knitr calls as well, so you will need to look near the end to find the calls in your code.\n\n\n\nNote you cannot use the ‘Knit’ button in RStudio when trying to debug R Markdown documents in any case. The ‘Knit’ button opens a separate R process, so there is no way to use an interactive debugger in that case.\n\n\n\n\n10.4.1 Resources\n\nDebugging techniques in RStudio - Amanda Gadrow’s talk at rstudio::conf 2018\nDebugging in RStudio article"
  },
  {
    "objectID": "read-source.html#github-search",
    "href": "read-source.html#github-search",
    "title": "11  Read the source",
    "section": "11.1 GitHub search",
    "text": "11.1 GitHub search\nGitHub allows you to search code, repositories, and issues which can often reveal useful insights into problems.\nDoing a generic search is often fruitful, but you can often get more pertinent results with a more targeted approach."
  },
  {
    "objectID": "read-source.html#where-things-exist-in-the-r-source",
    "href": "read-source.html#where-things-exist-in-the-r-source",
    "title": "11  Read the source",
    "section": "11.2 Where things exist in the R source",
    "text": "11.2 Where things exist in the R source\nThe SVN repository used by the R core team to develop R is mirrored on GitHub by Winston Chang at https://github.com/wch/r-source. This means that all the code used by your local R session (including compiled code) is searchable.\nThe R source uses a complicated layout and contains the source of all the code in base R (src/main) as well as the set of packages included in base R, such as stats, graphics, utils and others (src/library/*). It also contains all of the documentation included in R including Writing R extensions, R internals and R admin guides (doc/manual).\n\n\n\nTry the activity usethis::use_course(“rstd.io/wtf-read-source”)\n\n\nto search the R source for code and documentation."
  },
  {
    "objectID": "read-source.html#where-things-exist-in-cran-packages",
    "href": "read-source.html#where-things-exist-in-cran-packages",
    "title": "11  Read the source",
    "section": "11.3 Where things exist in CRAN packages",
    "text": "11.3 Where things exist in CRAN packages\nYou can find the development home of most R packages by looking at the URL field in the package DESCRIPTION, as can be seen on the CRAN landing page (e.g. devtools landing page). The BugReports field will give you a direct link to the issue page where you should report any issues found with the package.\nIn addition all code for CRAN packages is mirrored on GitHub by Gábor Csárdi at https://github.com/cran, which means all the code for CRAN packages is also searchable.\nAll R code in packages is kept in R/. In addition if the package is using roxygen the source code will also contain roxygen comments (#') with the function level documentation.\nIf a package is not using roxygen (often older packages or those in base R) the documentation will be in .Rd files in the man/ directory. (These files also exist in roxygen packages, but are generated automatically and should not be edited by hand).\nIf the package uses compiled code it will be in src/ regardless of what language the compiled code is written in.\nLong-form documentation in the form of vignettes are stored in vignettes/.\n\n\n\nTry the activity usethis::use_course(“rstd.io/wtf-read-source”)\n\n\nto search and find source code and documentation in CRAN packages."
  },
  {
    "objectID": "reprexing.html",
    "href": "reprexing.html",
    "title": "12  Reproduce the problem",
    "section": "",
    "text": "Before you seek outside help, strive to nail down your problem with this level of rigor:\n\nYou can reliably induce it, with minimal setup and fuss. To the point where others can reproduce it.\n\nDiscuss “bisect” as a useful mentality, applied to lines of code / functions or across versions.\nLink out to reprex stuff re: mechanics of sharing."
  },
  {
    "objectID": "sessioninfo.html",
    "href": "sessioninfo.html",
    "title": "Session info",
    "section": "",
    "text": "git2r::repository()\n\nLocal:    main /home/runner/work/what-they-forgot/what-they-forgot\nRemote:   main @ origin (https://github.com/rstats-wtf/what-they-forgot)\nHead:     [4f2642c] 2023-04-14: Meaningless whitespace but still\n\nsessioninfo::session_info()\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.2.3 (2023-03-15)\n os       Ubuntu 22.04.2 LTS\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  C.UTF-8\n ctype    C.UTF-8\n tz       UTC\n date     2023-04-15\n pandoc   2.9.2.1 @ /usr/bin/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n cli           3.6.1   2023-03-23 [1] RSPM\n digest        0.6.31  2022-12-11 [1] RSPM\n evaluate      0.20    2023-01-17 [1] RSPM\n fastmap       1.1.1   2023-02-24 [1] RSPM\n git2r         0.32.0  2023-04-12 [1] RSPM\n htmltools     0.5.5   2023-03-23 [1] RSPM\n jsonlite      1.8.4   2022-12-06 [1] RSPM\n knitr         1.42    2023-01-25 [1] RSPM\n rlang         1.1.0   2023-03-14 [1] RSPM\n rmarkdown     2.21    2023-03-26 [1] RSPM\n sessioninfo   1.2.2   2021-12-06 [1] any (@1.2.2)\n xfun          0.38    2023-03-24 [1] RSPM\n\n [1] /home/runner/work/_temp/Library\n [2] /opt/R/4.2.3/lib/R/site-library\n [3] /opt/R/4.2.3/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────────"
  }
]